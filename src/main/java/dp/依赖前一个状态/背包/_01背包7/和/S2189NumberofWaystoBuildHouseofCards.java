package dp.依赖前一个状态.背包._01背包7.和;

/**
 底数 = 2 + 3k
 从上往下底数至少不断+3，因此底数越来越大，并且可以承接不同大小的上层。即比如底=2+3*3=11，可以容纳底<=8组成的上层，也可以容纳底 <= 2组成的上层
 所以当前底需要对不同的上层已知答案+1，拼凑出最新的组合。

 上下层依赖 依赖前一个状态
 每一层依赖前面所有层的状态

 n 可能依赖 n-2 n-5 n-8 等等 >> 这个是最后的递推公式
 上下层依赖，可能是跨越的，所以需要模拟所有情况。依赖前面特定解

 同一行N个三角形需要的卡片数量： 第一个三角需要2张， 之后每个三角形需要3张
 合理的图案三角形数量从上到下是依次递增的
 01背包问题， 我们需要取三角形数量依次递增的序列

 最新最大的底，一定可以承接之前计算出的所有结果 f[j - i]
 倒着减就是为了只计算一次而已
 j 可能由不同长度的底组成

 总和是一样的
 */
public class S2189NumberofWaystoBuildHouseofCards {

	public int houseOfCards(int n) {
		int[] f = new int[n + 1];
		f[0] = 1;
		for (int i = 2; i <= n; i += 3) {
			for (int j = n; j >= i; --j) {
				f[j] += f[j - i];
			}
		}
		return f[n];
	}

}
